---
alwaysApply: true
---

# Internationalization (i18n) & Localization Standards

## Purpose
Ensure every user-facing string is translatable for a consistent, accessible experience across Android, iOS, and Web, with minimal dependencies.

## Core Rules

1. **No Hardcoded UI Text**
   - All user-visible text must use `t()` or `tSync()` from `useI18n()`.
   - Applies to all UI text: labels, placeholders, button text, error/success messages, tooltips, accessibility text, titles, navigation, forms, state messages, etc.
   - *Exceptions*: Technical data (IDs, keys, API endpoints) and untranslatable brand names.

2. **Translation Key Consistency**
   - Every translation key must exist in every locale file.
   - No key may be missing from any supported language.

3. **Stable, Descriptive Key Naming**
   - Use dot notation reflecting domain/feature structure (e.g., `auth.login`, `errors.networkError`).
   - Group keys by logical area (e.g., `common.*`, `forms.*`, `errors.*`, `navigation.*`).
   - Avoid generic or unstable names (e.g., `text1`, `labelX`).

4. **Automated & Manual Enforcement**
   - No hardcoded strings allowed in UI code (JSX/TSX).
   - All new keys must be present in all locale files before use.
   - All visible error, form, accessibility, and non-dev user logs must be internationalized.
   - **Automation:** Linters/checks flag hardcoded UI strings and missing keys; tests validate key presence.
   - **Review:** Code reviews verify full i18n coverage.

## Source of Truth

All translations must live exclusively in `src/i18n/locales/`. This folder is the single source of user-facing strings.

### Folder Structure & Supported Languages

```txt
src/i18n/
  ├── index.js              # i18n bootstrap
  └── locales/
      ├── en.json    # English [en] (default)
      ├── zh.json    # Mandarin Chinese [zh]
      ├── hi.json    # Hindi [hi]
      ├── es.json    # Spanish [es]
      ├── fr.json    # French [fr]
      ├── ar.json    # Arabic [ar]
      ├── bn.json    # Bengali [bn]
      ├── pt.json    # Portuguese [pt]
      ├── ru.json    # Russian [ru]
      ├── ur.json    # Urdu [ur]
      ├── id.json    # Indonesian [id]
      ├── de.json    # German [de]
      ├── ja.json    # Japanese [ja]
      ├── pcm.json   # Nigerian Pidgin [pcm]
      ├── mr.json    # Marathi [mr]
      ├── te.json    # Telugu [te]
      ├── tr.json    # Turkish [tr]
      ├── ta.json    # Tamil [ta]
      ├── yue.json   # Cantonese [yue]
      ├── vi.json    # Vietnamese [vi]
      ├── sw.json    # Swahili [sw]
      └── lg.json    # Luganda [lg]
```

## Usage

```javascript
// Correct: uses i18n system
import { useI18n } from '@hooks';
const { t } = useI18n();
<Text>{t('common.save')}</Text>

// Incorrect: hardcoded string (not allowed)
<Text>Save</Text>
```

## Implementation Standards

- Use native `Intl` APIs for formatting numbers, dates, and currency.
- Language defaults to device/browser locale but allows persistent user override; always fallback to English if missing.
- Never crash on missing translations; always fallback to `en`. Optionally warn outside production.
- Support RTL (right-to-left) languages for both text and layout direction.
- All error messages delivered to UI must be internationalized.
- Avoid unnecessary external i18n dependencies. Use polyfills for essential missing `Intl` support only.

## Process for Adding New Translations

1. Add new translation keys to **all 22 locale files** before usage in code.
2. Reference only via `t()` or `tSync()`, never with string literals.
3. Validate appearance in all supported languages.
4. Update this standard if organizational structure changes.
