---
alwaysApply: true
---

# Domain & Features Architecture Standards

## Purpose
Defines how **business logic (domain rules)** is structured and enforced in the application.

Goals:
- Centralize business logic outside the UI
- Enable reusable, testable, platform-agnostic features
- Prevent domain logic from leaking into UI or infrastructure

The **Features layer** is the business heart of the app.

---

## What is a Feature?

A **feature** captures a real-world domain concept (e.g., Authentication, Users, Payments).

A feature:
- Owns its business rules and data validation
- Defines domain models
- Orchestrates services and state
- Has **no knowledge of UI, platform, or navigation**

---

## Standard Feature Folder Structure

Every feature **must** follow this structure:

```txt
src/features/
├── index.js             # Barrel file: re-exports all feature modules
└── feature-name/
    ├── feature-name.rules.js     # Business rules & validation
    ├── feature-name.model.js     # Domain models
    ├── feature-name.api.js       # Feature-level API orchestration
    ├── feature-name.usecase.js   # Application use cases
    ├── feature-name.events.js    # Domain events (optional)
    └── index.js
```

> For Redux/store or hook integration, see "Redux & Hooks Integration" below.

---

## Feature Responsibility Boundaries

### Features **MAY**:
- Validate and transform inputs
- Enforce business rules
- Normalize API/service responses
- Coordinate multiple services and state
- Expose use cases and trigger Redux actions

### Features **MUST NOT**:
- Import or use UI/components/screens/layouts
- Use React hooks
- Manipulate navigation or platform APIs
- Access themes or styling

---

## Core File Roles

### Business Rules (`*.rules.js`)
Pure, synchronous functions only—no side effects or async calls.
Example:

```js
// Example: access control
const canAccessFeature = (user, feature) => {/* ... */};
export { canAccessFeature };
```

---

### Domain Models (`*.model.js`)
Functions for normalizing and validating API/service data to domain-safe shapes.
Example:

```js
const UserModel = (raw) => ({
  id: raw.id,
  email: raw.email
});
export { UserModel };
```

---

### APIs (`*.api.js`)
Wrap calls to services or backend APIs. No UI or Redux logic.

```js
import { apiClient } from '@services/api';
const loginApi = (payload) => {/* ... */};
export { loginApi };
```

---

### Use Cases (`*.usecase.js`)
The only file with application logic. Orchestrates rules, models, APIs, and can (optionally) dispatch Redux actions.

```js
const loginUseCase = async (payload, dispatch) => {/* ... */};
export { loginUseCase };
```

---

### Events (`*.events.js`) (optional)
Defines domain events (pure definitions, no side effects).

---

### Barrel Export (`index.js`)
Export only public APIs, hiding internals:

```js
export * from './auth.usecase';
export * from './auth.rules';
export * from './auth.model';
export * from './auth.api';
```

---

## Allowed & Forbidden Dependencies

**Allowed:**
```txt
features → services
features → store
features → utils
```

**Forbidden:**
```txt
features → platform
features → app
features → navigation
features → UI/components
features ↔ other features (no inter-feature imports)
```

---

## How UI interacts with Features

UI **should only**:
- Use feature hooks or dispatch use cases
- Render resulting state

Example:
```js
dispatch(loginUseCase(payload));
```

UI **must NOT**:
- Implement business rules
- Transform domain data
- Call services/APIs directly

---

## Offline & Background

Features **may**:
- Push work to offline queues
- Trigger or react to background workers
- Resume/continue operations after hydration

---

## Error Handling

- All errors returned must be domain-specific and normalized (never raw backend errors)
- Only error codes (not raw error objects) are stored in Redux
- Features must not expose implementation details

---

## Feature Template & Checklist

**A feature is complete only if:**
- All core files above exist and follow this structure
- Barrel exports public APIs only
- If global state is required:
  - There is a slice at `src/store/slices/<feature>.slice.js`
  - Only error codes stored, not raw objects
  - All reducers are pure; use `createAsyncThunk` for async
- If UI access is needed:
  - There is a semantic hook `src/hooks/use<Feature>.js` (the only gateway to UI)
  - Hook always normalizes and exposes error codes only
- **Testing:** For every file (and for slices/hooks), there is a matching test file in `src/__tests__` with 100% coverage (including all error paths)

**Testing structure:**
```txt
src/__tests__/features/<feature>/<feature>.rules.test.js
src/__tests__/features/<feature>/<feature>.model.test.js
src/__tests__/features/<feature>/<feature>.api.test.js
src/__tests__/features/<feature>/<feature>.usecase.test.js
src/__tests__/store/slices/<feature>.slice.test.js      # if slice exists
src/__tests__/hooks/use<Feature>.test.js                # if hook exists
```

---

## Strictly Forbidden Patterns

❌ Business logic inside components  
❌ API calls from UI or outside feature API  
❌ Redux/store logic in services  
❌ Features depending on other features  
❌ "God" features (feature doing too much)  
❌ Skipping standard file/test structure  
❌ Missing test coverage for any feature file

---

**All business/domain logic must reside exclusively in features.**

Single source of truth for feature test requirements: `testing.mdc`.
