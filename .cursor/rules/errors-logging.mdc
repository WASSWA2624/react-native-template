---
alwaysApply: true
---

# Error Handling & Logging Standards
## Purpose
This document defines **how errors are detected, handled, logged, and reported** across the application.
Goals:
- Prevent crashes and undefined states
- Provide consistent user feedback
- Enable observability and debugging
- Separate error handling from UI and business logic
Errors are **signals**, not UI.
---

## Error Ownership Model
| Layer        | Responsibility |
|-------------|----------------|
| UI           | Display safe fallback UI |
| Hooks        | Normalize and expose errors |
| Store        | Store error states (codes only) |
| Services     | Detect technical failures |
| Errors Layer | Centralize error handling logic |
| Logging      | Record and report issues |
---

## Folder Structure
```txt
src/errors/
    ├── index.js                # Public error API
    ├── ErrorBoundary.jsx       # Global error boundary
    ├── error.handler.js        # Error normalization & routing
    └── fallback.ui.jsx         # Generic fallback UI
src/logging/
    ├── index.js                # Logging entry
    ├── logger.js               # Logger implementation
    └── levels.js               # Log levels
```
---

## Error Boundary Rules
### Global Boundary
* A single global `ErrorBoundary` must wrap the app
* ErrorBoundary mounted in `src/app/_layout.jsx` only (see `bootstrap-config.mdc`).
Responsibilities:
* Catch render/runtime errors
* Display fallback UI
* Report fatal errors to logger
Forbidden:
❌ Multiple global error boundaries
❌ Business logic inside error boundaries
---

## Fallback UI Rules
Fallback UI:
* Must be minimal and accessible
* Must not expose internal error details
* Must allow retry or safe exit when applicable
Rules:
* No stack traces
* No raw error objects
* No sensitive data
---

## Error Normalization
### `error.handler.js`
All errors must pass through a **single normalization layer**.
Responsibilities:
* Convert raw errors into domain-safe error objects
* Map technical errors to error codes
* Strip sensitive data
Example output:
```js
{
  code: 'NETWORK_TIMEOUT',
  message: 'Unable to connect',
  severity: 'warning',
}
```
Rules:
* UI never sees raw errors
* Store only error codes
* Services never format UI messages
---

## Service Error Rules
Services:
* Detect technical failures
* Throw normalized errors or error codes
* Never swallow errors silently
Forbidden:
❌ UI-specific error messages
❌ Logging inside services
---

## Hook Error Rules
Hooks:
* Catch service/store errors
* Expose semantic error states
* Provide retry APIs
Allowed:
```js
const { error, retry } = useLogin();
```
Forbidden:
❌ Alerts inside hooks
❌ Toasts inside hooks
---

## Redux Error Handling
Redux:
* Store error **codes only**
* No raw error objects
* Errors cleared explicitly
Example:
```js
state.errorCode = 'AUTH_FAILED';
```
---

## Logging Standards
### Logger Responsibilities
The logger:
* Records structured logs
* Applies log levels
* Forwards logs to analytics/monitoring
Log levels:
* `debug`
* `info`
* `warn`
* `error`
* `fatal`
---

### Logging Rules
Allowed to log:
* Errors
* Performance metrics
* State transitions
* Critical lifecycle events
Forbidden to log:
❌ Tokens
❌ Personal data
❌ Raw request bodies
❌ Secrets
---

## Logging Placement
Logging is allowed only in:
* Error handlers
* Middleware
* Workers
* Bootstrap
Forbidden:
❌ UI components
❌ Pure utilities
---

## Monitoring & Reporting
If external monitoring is enabled:
* Integrate via `logging/`
* Centralized configuration
* Environment-aware (dev vs prod)
---

## Offline Error Handling
Rules:
* Offline errors must be distinguishable
* Sync failures must be recoverable
* No crash on network loss
---

## Forbidden Patterns
❌ `try/catch` scattered across UI
❌ `console.log` in production code
❌ Throwing raw errors to UI
❌ Logging inside render functions
---