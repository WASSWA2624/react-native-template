---
alwaysApply: true
---

# State Management Standards (Redux Toolkit)

## Purpose
This document defines **how global state is designed, implemented, and accessed** in the application.

Goals:
* Predictable and scalable state management
* Clear separation between **UI**, **domain**, and **infrastructure**
* Minimal side effects in UI
* First-class support for **offline**, **persistence**, and **security**
Redux Toolkit (RTK) is the **only approved global state solution**.
---

## State Layer Responsibility
The **State Layer**:
* Stores **global application state**
* Coordinates **side effects** (via middleware)
* Acts as a **bridge** between UI and domain/services

It does **not**:
* Contain UI logic
* Call UI components
* Implement business rules directly
---

## Folder Ownership
```txt
src/store/
├── index.js            # Store creation
├── rootReducer.js      # Combined reducers
├── middleware.js       # Custom middleware
├── persist.js          # Persistence configuration
├── slices/             # Feature slices
├── selectors/          # Memoized selectors
└── types.js            # Shared state types
```
---

## Store Creation Rules
### Store Setup
* Use `configureStore`
* Enable Redux DevTools **only in development**
* Middleware must be explicitly declared
```js
configureStore({
  reducer,
  middleware,
  devTools: __DEV__,
});
```

### Provider Placement
See `bootstrap-config.mdc`.
---

## Slice Design Rules
### Slice Scope
Each slice:
* Represents **one domain concern**
* Must be small and focused
* Must not grow indefinitely
Good examples:
* `auth.slice.js`
* `ui.slice.js`
* `network.slice.js`
Bad examples:
* `app.slice.js`
* `global.slice.js`
---

### Slice Structure
```js
const slice = createSlice({
  name,
  initialState,
  reducers,
  extraReducers,
});
```

Rules:
* Reducers must be **pure**
* No async logic inside reducers
* No direct API calls
---

## Async Logic Rules
### Async Operations
Async logic must be handled using:
* `createAsyncThunk`
* Custom middleware
* Services called from thunks
```js
import { createAsyncThunk } from '@reduxjs/toolkit';
import { loginApi } from '@features/auth';

const login = createAsyncThunk(
  'auth/login',
  async (payload, { rejectWithValue }) => {
    try {
      const result = await loginApi(payload);
      return result;
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);

export { login };
```
Rules:
* Thunks may call `services/`
* Thunks must not touch UI
* Errors must be normalized
---

## Side Effects & Middleware
### Allowed Side Effects Locations
* Redux middleware
* Thunks
* Workers
* Offline queue

### Custom Middleware
Use middleware for:
* Logging
* Analytics
* Persistence triggers
* Security enforcement
```txt
src/store/middleware.js
```
---

## Selectors
### Selector Rules
* All selectors must live in `store/selectors`
* Use `reselect` for memoization
* UI must **never** access state directly
Selectors are intended to be consumed by **hooks** (see `hooks-utils.mdc`).
Rules:
* One selector = one concern
* No computed logic inside components
---

## UI Interaction Rules
### UI → State
UI may:
* Dispatch actions (via hooks)
* Read state (via hooks)
UI must not:
* Modify state directly
* Know about reducers
* Contain state logic
---

## Domain Interaction Rules
### Features ↔ Store
* Features **may define** actions
* Features **must not** import UI
* Features **may not** depend on React
Allowed:
```txt
features → store
```
Forbidden:
```txt
store → platform
```
---

## Persistence Rules
### Persistence Scope
Persist only:
* Auth tokens (securely)
* User preferences
* Feature flags
Never persist:
* Derived UI state
* Temporary flags
* Network loading states
Persistence config lives in:
```txt
src/store/persist.js
```
---

## Offline Integration
Redux must integrate with:
* Offline queue
* Network status slice
* Sync manager
Rules:
* Offline failures must not crash UI
* State must be recoverable after restart
---

## Error Handling
### Error State Rules
* Errors must be normalized
* Store only error **codes**, not raw objects
* UI decides how to display errors
---

## Forbidden Patterns
❌ Calling APIs inside reducers
❌ Importing UI into store
❌ Using Redux for local component state
❌ Large monolithic slices
❌ Storing functions in state
